(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[9],{T1Xd:function(e,t,n){"use strict";n.r(t),n.d(t,"DefaultValue",(function(){return pa})),n.d(t,"RecoilRoot",(function(){return va})),n.d(t,"atom",(function(){return ma})),n.d(t,"atomFamily",(function(){return Sa})),n.d(t,"batchUpdates",(function(){return ja})),n.d(t,"constSelector",(function(){return ba})),n.d(t,"errorSelector",(function(){return Ra})),n.d(t,"isRecoilValue",(function(){return qa})),n.d(t,"noWait",(function(){return Oa})),n.d(t,"readOnlySelector",(function(){return Ta})),n.d(t,"retentionZone",(function(){return ga})),n.d(t,"selector",(function(){return _a})),n.d(t,"selectorFamily",(function(){return wa})),n.d(t,"setBatcher",(function(){return Ha})),n.d(t,"snapshot_UNSTABLE",(function(){return $a})),n.d(t,"useGetRecoilValueInfo_UNSTABLE",(function(){return Ma})),n.d(t,"useGotoRecoilSnapshot",(function(){return Ua})),n.d(t,"useRecoilBridgeAcrossReactRoots_UNSTABLE",(function(){return ya})),n.d(t,"useRecoilCallback",(function(){return Ba})),n.d(t,"useRecoilSnapshot",(function(){return Da})),n.d(t,"useRecoilState",(function(){return Na})),n.d(t,"useRecoilStateLoadable",(function(){return ka})),n.d(t,"useRecoilTransactionObserver_UNSTABLE",(function(){return Ia})),n.d(t,"useRecoilValue",(function(){return Aa})),n.d(t,"useRecoilValueLoadable",(function(){return Ea})),n.d(t,"useResetRecoilState",(function(){return La})),n.d(t,"useRetain",(function(){return Ca})),n.d(t,"useSetRecoilState",(function(){return Va})),n.d(t,"useSetUnvalidatedAtomValues_UNSTABLE",(function(){return Fa})),n.d(t,"useTransactionObservation_UNSTABLE",(function(){return xa})),n.d(t,"waitForAll",(function(){return Ga})),n.d(t,"waitForAllSettled",(function(){return Wa})),n.d(t,"waitForAny",(function(){return Pa})),n.d(t,"waitForNone",(function(){return za}));var o=n("i8i4"),r=n.n(o),a=n("q1tI"),i=n.n(a);var s=function(e){return!!e&&"function"===typeof e.then};var u=function(e,t){if(null!=e)return e;throw new Error(null!==t&&void 0!==t?t:"Got unexpected null or undefined")};class c{}const l=new c,d={valueMaybe(){},valueOrThrow(){throw new Error(`Loadable expected value, but in "${this.state}" state`)},errorMaybe(){},errorOrThrow(){throw new Error(`Loadable expected error, but in "${this.state}" state`)},promiseMaybe(){},promiseOrThrow(){throw new Error(`Loadable expected promise, but in "${this.state}" state`)},is(e){return e.state===this.state&&e.contents===this.contents},map(e){if("hasError"===this.state)return this;if("hasValue"===this.state)try{const t=e(this.contents);return s(t)?p(t):f(t)}catch(t){return s(t)?p(t.next(()=>e(this.contents))):h(t)}if("loading"===this.state)return p(this.contents.then(e).catch(t=>{if(s(t))return t.then(()=>e(this.contents));throw t}));throw new Error("Invalid Loadable state")}};function f(e){return Object.freeze({state:"hasValue",contents:e,...d,getValue(){return this.contents},toPromise(){return Promise.resolve(this.contents)},valueMaybe(){return this.contents},valueOrThrow(){return this.contents}})}function h(e){return Object.freeze({state:"hasError",contents:e,...d,getValue(){throw this.contents},toPromise(){return Promise.reject(this.contents)},errorMaybe(){return this.contents},errorOrThrow(){return this.contents}})}function p(e){return Object.freeze({state:"loading",contents:e,...d,getValue(){throw this.contents.then(({__value:e})=>e)},toPromise(){return this.contents.then(({__value:e})=>e)},promiseMaybe(){return this.contents.then(({__value:e})=>e)},promiseOrThrow(){return this.contents.then(({__value:e})=>e)}})}var v={loadableWithValue:f,loadableWithError:h,loadableWithPromise:p,loadableLoading:function(){return p(new Promise(()=>{}))},loadableAll:function(e){return e.every(e=>"hasValue"===e.state)?f(e.map(e=>e.contents)):e.some(e=>"hasError"===e.state)?h(u(e.find(e=>"hasError"===e.state),"Invalid loadable passed to loadableAll").contents):p(Promise.all(e.map(e=>e.contents)).then(e=>({__value:e})))},Canceled:c,CANCELED:l};var y=function(e,t,{error:n}={}){return null};var m={setByAddingToSet:function(e,t){const n=new Set(e);return n.add(t),n},setByDeletingFromSet:function(e,t){const n=new Set(e);return n.delete(t),n},mapBySettingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n),o},mapByUpdatingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o},mapByDeletingFromMap:function(e,t){const n=new Map(e);return n.delete(t),n},mapByDeletingMultipleFromMap:function(e,t){const n=new Map(e);return t.forEach(e=>n.delete(e)),n}};var _=function*(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)};const g=(new Map).set("recoil_hamt_2020",!0).set("recoil_memory_managament_2020",!0);function S(e){var t;return null!==(t=g.get(e))&&void 0!==t&&t}S.setPass=e=>{g.set(e,!0)},S.setFail=e=>{g.set(e,!1)};var w=S;var b=function(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()};var R=function(e,...t){0};function T(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class A{constructor(e){T(this,"key",void 0),this.key=e}}class E extends A{}class N extends A{}var k={AbstractRecoilValue:A,RecoilState:E,RecoilValueReadOnly:N,isRecoilValue:function(e){return e instanceof E||e instanceof N}},V=k.AbstractRecoilValue,L=k.RecoilState,M=k.RecoilValueReadOnly,C=k.isRecoilValue,B=Object.freeze({__proto__:null,AbstractRecoilValue:V,RecoilState:L,RecoilValueReadOnly:M,isRecoilValue:C});class U{}const D=new U;class I extends Error{constructor(e){super(`Tried to set the value of Recoil selector ${e} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const x=new Map,F=new Map;class O extends Error{}const z=new Map;function P(e){return z.get(e)}var G={nodes:x,recoilValues:F,registerNode:function(e){if(x.has(e.key)){const t=`Duplicate atom key "${e.key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(t)}x.set(e.key,e);const t=null==e.set?new B.RecoilValueReadOnly(e.key):new B.RecoilState(e.key);return F.set(e.key,t),t},getNode:function(e){const t=x.get(e);if(null==t)throw new O(`Missing definition for RecoilValue: "${e}""`);return t},getNodeMaybe:function(e){return x.get(e)},deleteNodeConfigIfPossible:function(e){var t;if(!w("recoil_memory_managament_2020"))return;const n=x.get(e);var o;(null===n||void 0===n||null===(t=n.shouldDeleteConfigOnRelease)||void 0===t?void 0:t.call(n))&&(x.delete(e),null===(o=P(e))||void 0===o||o(),z.delete(e))},setConfigDeletionHandler:function(e,t){w("recoil_memory_managament_2020")&&(void 0===t?z.delete(e):z.set(e,t))},getConfigDeletionHandler:P,recoilValuesForKeys:function(e){return b(e,e=>u(F.get(e)))},NodeMissingError:O,DefaultValue:U,DEFAULT_VALUE:D,RecoilValueNotReady:I};class W{}var q={RetentionZone:W,retentionZone:function(){return new W}};const{setByAddingToSet:j}=m,{getNode:H,getNodeMaybe:$,recoilValuesForKeys:K}=G,{RetentionZone:Z}=q,J=Object.freeze(new Set);class X extends Error{}function Q(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=H(n),i=function(e,t,n){if(!w("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(e){let n=o.get(e);n||o.set(e,n=new Set),n.add(t)}if(n instanceof Z)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!w("recoil_memory_managament_2020"))return;const o=e.getState().retention.nodesRetainedByZone;function r(e){const n=o.get(e);n&&n.delete(t),n&&0===n.size&&o.delete(e)}if(n instanceof Z)r(n);else if(Array.isArray(n))for(const e of n)r(e)}}(e,n,a.retainedBy),s=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{s(),i()})}function Y(e,t,n){return H(n).peek(e,t)}function ee(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let s=r.pop();s;s=r.pop()){var i;o.add(s);const e=null!==(i=a.nodeToNodeSubscriptions.get(s))&&void 0!==i?i:J;for(const t of e)o.has(t)||r.push(t)}return o}var te={getNodeLoadable:function(e,t,n){return Q(e,t,n,"get"),H(n).get(e,t)},peekNodeLoadable:Y,setNodeValue:function(e,t,n,o){const r=H(n);if(null==r.set)throw new X("Attempt to set read-only RecoilValue: "+n);const a=r.set;return Q(e,t,n,"set"),a(e,t,o)},cleanUpNode:function(e,t){var n;const o=e.getState();null===(n=o.nodeCleanupFunctions.get(t))||void 0===n||n(),o.nodeCleanupFunctions.delete(t)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,n){var o;const r=$(t);return null===r||void 0===r||null===(o=r.invalidate)||void 0===o||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:j(e.dirtyAtoms,t)}},peekNodeInfo:function(e,t,n){var o,r,a;const i=e.getState(),s=e.getGraph(t.version),u=i.knownAtoms.has(n)?"atom":i.knownSelectors.has(n)?"selector":void 0,c=_(ee(e,t,new Set([n])),e=>e!==n);return{loadable:Y(e,t,n),isActive:i.knownAtoms.has(n)||i.knownSelectors.has(n),isSet:"selector"!==u&&t.atomValues.has(n),isModified:t.dirtyAtoms.has(n),type:u,deps:K(null!==(o=s.nodeDeps.get(n))&&void 0!==o?o:[]),subscribers:{nodes:K(c),components:b(null!==(r=null===(a=i.nodeToComponentSubscriptions.get(n))||void 0===a?void 0:a.values())&&void 0!==r?r:[],([e])=>({name:e}))}}},getDownstreamNodes:ee,initializeNodeIfNewToStore:Q};const{CANCELED:ne}=v,{getDownstreamNodes:oe,getNodeLoadable:re,setNodeValue:ae}=te,{getNodeMaybe:ie}=G,{DefaultValue:se,RecoilValueNotReady:ue}=G,{AbstractRecoilValue:ce,RecoilState:le,RecoilValueReadOnly:de,isRecoilValue:fe}=B;function he(e,t,n){if("set"===n.type){const{recoilValue:o,valueOrUpdater:r}=n,a=function(e,t,{key:n},o){if("function"===typeof o){const r=re(e,t,n);if("loading"===r.state)throw new ue(n);if("hasError"===r.state)throw r.contents;return o(r.contents)}return o}(e,t,o,r),i=ae(e,t,o.key,a);for(const[e,n]of i.entries())pe(t,e,n)}else if("setLoadable"===n.type){const{recoilValue:{key:e},loadable:o}=n;pe(t,e,o)}else if("markModified"===n.type){const{recoilValue:{key:e}}=n;t.dirtyAtoms.add(e)}else if("setUnvalidated"===n.type){var o;const{recoilValue:{key:e},unvalidatedValue:r}=n,a=ie(e);null===a||void 0===a||null===(o=a.invalidate)||void 0===o||o.call(a,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,r),t.dirtyAtoms.add(e)}else y("Unknown action "+n.type)}function pe(e,t,n){"hasValue"===n.state&&n.contents instanceof se?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function ve(e,t){e.replaceState(n=>{const o=function(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}(n);for(const r of t)he(e,o,r);return _e(e,o),o})}function ye(e,t){if(me.length){const n=me[me.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else ve(e,[t])}const me=[];function _e(e,t){const n=oe(e,t,t.dirtyAtoms);for(const a of n){var o,r;null===(o=ie(a))||void 0===o||null===(r=o.invalidate)||void 0===r||r.call(o,t)}}function ge(e,t,n){ye(e,{type:"set",recoilValue:t,valueOrUpdater:n})}let Se=0;var we={RecoilValueReadOnly:de,AbstractRecoilValue:ce,RecoilState:le,getRecoilValueAsLoadable:function(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version!==a.currentTree.version&&n.version!==(null===(o=a.nextTree)||void 0===o?void 0:o.version)&&n.version!==(null===(r=a.previousTree)||void 0===r?void 0:r.version)&&y("Tried to read from a discarded tree");const i=re(e,n,t);return"loading"===i.state&&i.contents.catch(()=>ne),i},setRecoilValue:ge,setRecoilValueLoadable:function(e,t,n){if(n instanceof se)return ge(e,t,n);ye(e,{type:"setLoadable",recoilValue:t,loadable:n})},markRecoilValueModified:function(e,t){ye(e,{type:"markModified",recoilValue:t})},setUnvalidatedRecoilValue:function(e,t,n){ye(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})},subscribeToRecoilValue:function(e,{key:t},n,o=null){const r=Se++,a=e.getState();return a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),u(a.nodeToComponentSubscriptions.get(t)).set(r,[null!==o&&void 0!==o?o:"<not captured>",n]),{release:()=>{const n=e.getState(),o=n.nodeToComponentSubscriptions.get(t);void 0!==o&&o.has(r)?(o.delete(r),0===o.size&&n.nodeToComponentSubscriptions.delete(t)):y(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`)}}},isRecoilValue:fe,applyAtomValueWrites:function(e,t){const n=e.clone();return t.forEach((e,t)=>{"hasValue"===e.state&&e.contents instanceof se?n.delete(t):n.set(t,e)}),n},batchStart:function(){const e=new Map;return me.push(e),()=>{for(const[t,n]of e)ve(t,n);me.pop()!==e&&y("Incorrect order of batch popping")}},invalidateDownstreams_FOR_TESTING:_e};const{unstable_batchedUpdates:be}=r.a;var Re={unstable_batchedUpdates:be};const{unstable_batchedUpdates:Te}=Re;var Ae={unstable_batchedUpdates:Te};const{batchStart:Ee}=we,{unstable_batchedUpdates:Ne}=Ae;let ke=Ne;var Ve={getBatcher:()=>ke,setBatcher:e=>{ke=e},batchUpdates:e=>{ke(()=>{let t=()=>{};try{t=Ee(),e()}finally{t()}})}};var Le={enqueueExecution:function(e,t){t()}};var Me=function(e,...t){const n=new Set;e:for(const o of e){for(const e of t)if(e.has(o))continue e;n.add(o)}return n};var Ce=function(e,t){const n=new Map;return e.forEach((e,o)=>{n.set(o,t(e,o))}),n};function Be(e,t,n){const{nodeDeps:o,nodeToNodeSubscriptions:r}=t;e.forEach((e,t)=>{const a=o.get(t);if(a&&n&&a!==n.nodeDeps.get(t))return;o.set(t,new Set(e));if((null==a?e:Me(e,a)).forEach(e=>{r.has(e)||r.set(e,new Set);u(r.get(e)).add(t)}),a){Me(a,e).forEach(e=>{if(!r.has(e))return;const n=u(r.get(e));n.delete(t),0===n.size&&r.delete(e)})}})}var Ue={addToDependencyMap:function(e,t,n){n.has(e)||n.set(e,new Set),u(n.get(e)).add(t)},cloneGraph:function(e){return{nodeDeps:Ce(e.nodeDeps,e=>new Set(e)),nodeToNodeSubscriptions:Ce(e.nodeToNodeSubscriptions,e=>new Set(e))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(e,t){e.forEach((e,n)=>{t.has(n)||t.set(n,new Set);const o=u(t.get(n));e.forEach(e=>o.add(e))})},saveDependencyMapToStore:function(e,t,n){var o,r,a,i;const s=t.getState();n!==s.currentTree.version&&n!==(null===(o=s.nextTree)||void 0===o?void 0:o.version)&&n!==(null===(r=s.previousTree)||void 0===r?void 0:r.version)&&y("Tried to save dependencies to a discarded tree");const u=t.getGraph(n);if(Be(e,u),n===(null===(a=s.previousTree)||void 0===a?void 0:a.version)){Be(e,t.getGraph(s.currentTree.version),u)}if(n===(null===(i=s.previousTree)||void 0===i?void 0:i.version)||n===s.currentTree.version){var c;const n=null===(c=s.nextTree)||void 0===c?void 0:c.version;if(void 0!==n){Be(e,t.getGraph(n),u)}}}};var De=function(e,t){return e(t={exports:{}},t.exports),t.exports}((function(e){var t="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n={},o=Math.pow(2,5),r=o-1,a=o/2,i=o/4,s={},u=function(e){return function(){return e}},c=n.hash=function(e){var n="undefined"===typeof e?"undefined":t(e);if("number"===n)return e;"string"!==n&&(e+="");for(var o=0,r=0,a=e.length;r<a;++r){o=(o<<5)-o+e.charCodeAt(r)|0}return o},l=function(e,t){return t>>>e&r},d=function(e){return 1<<e},f=function(e,t){return n=e&t-1,n=(n=(858993459&(n-=n>>1&1431655765))+(n>>2&858993459))+(n>>4)&252645135,127&(n+=n>>8)+(n>>16);var n},h=function(e,t,n,o){var r=o;if(!e){var a=o.length;r=new Array(a);for(var i=0;i<a;++i)r[i]=o[i]}return r[t]=n,r},p=function(e,t,n){var o=n.length-1,r=0,a=0,i=n;if(e)r=a=t;else for(i=new Array(o);r<t;)i[a++]=n[r++];for(++r;r<=o;)i[a++]=n[r++];return e&&(i.length=o),i},v={__hamt_isEmpty:!0},y=function(e){return e===v||e&&e.__hamt_isEmpty},m=function(e,t,n,o){return{type:1,edit:e,hash:t,key:n,value:o,_modify:R}},_=function(e,t,n){return{type:2,edit:e,hash:t,children:n,_modify:T}},g=function(e,t,n){return{type:3,edit:e,mask:t,children:n,_modify:A}},S=function(e,t,n){return{type:4,edit:e,size:t,children:n,_modify:E}},w=function e(t,n,o,r,a,i){if(o===a)return _(t,o,[i,r]);var s=l(n,o),u=l(n,a);return g(t,d(s)|d(u),s===u?[e(t,n+5,o,r,a,i)]:s<u?[r,i]:[i,r])},b=function(e,t){return e===t.edit},R=function(e,t,n,o,r,a,i){if(t(a,this.key)){var u=o(this.value);return u===this.value?this:u===s?(--i.value,v):b(e,this)?(this.value=u,this):m(e,r,a,u)}var c=o();return c===s?this:(++i.value,w(e,n,this.hash,this,r,m(e,r,a,c)))},T=function(e,t,n,o,r,a,i){if(r===this.hash){var u=function(e,t,n,o,r,a,i,u){for(var c=r.length,l=0;l<c;++l){var d=r[l];if(n(i,d.key)){var f=d.value,v=a(f);return v===f?r:v===s?(--u.value,p(e,l,r)):h(e,l,m(t,o,i,v),r)}}var y=a();return y===s?r:(++u.value,h(e,c,m(t,o,i,y),r))}(b(e,this),e,t,this.hash,this.children,o,a,i);return u===this.children?this:u.length>1?_(e,this.hash,u):u[0]}var c=o();return c===s?this:(++i.value,w(e,n,this.hash,this,r,m(e,r,a,c)))},A=function(e,t,n,o,r,i,s){var u=this.mask,c=this.children,m=l(n,r),_=d(m),w=f(u,_),R=u&_,T=R?c[w]:v,A=T._modify(e,t,n+5,o,r,i,s);if(T===A)return this;var E,N=b(e,this),k=u,V=void 0;if(R&&y(A)){if(!(k&=~_))return v;if(c.length<=2&&((E=c[1^w])===v||1===E.type||2===E.type))return c[1^w];V=p(N,w,c)}else if(R||y(A))V=h(N,w,A,c);else{if(c.length>=a)return function(e,t,n,o,r){for(var a=[],i=o,s=0,u=0;i;++u)1&i&&(a[u]=r[s++]),i>>>=1;return a[t]=n,S(e,s+1,a)}(e,m,A,u,c);k|=_,V=function(e,t,n,o){var r=o.length;if(e){for(var a=r;a>=t;)o[a--]=o[a];return o[t]=n,o}for(var i=0,s=0,u=new Array(r+1);i<t;)u[s++]=o[i++];for(u[t]=n;i<r;)u[++s]=o[i++];return u}(N,w,A,c)}return N?(this.mask=k,this.children=V,this):g(e,k,V)},E=function(e,t,n,o,r,a,s){var u=this.size,c=this.children,d=l(n,r),f=c[d],p=(f||v)._modify(e,t,n+5,o,r,a,s);if(f===p)return this;var m=b(e,this),_=void 0;if(y(f)&&!y(p))++u,_=h(m,d,p,c);else if(!y(f)&&y(p)){if(--u<=i)return function(e,t,n,o){for(var r=new Array(t-1),a=0,i=0,s=0,u=o.length;s<u;++s)if(s!==n){var c=o[s];c&&!y(c)&&(r[a++]=c,i|=1<<s)}return g(e,i,r)}(e,u,d,c);_=h(m,d,v,c)}else _=h(m,d,p,c);return m?(this.size=u,this.children=_,this):S(e,u,_)};function N(e,t,n,o,r){this._editable=e,this._edit=t,this._config=n,this._root=o,this._size=r}v._modify=function(e,t,n,o,r,a,i){var u=o();return u===s?v:(++i.value,m(e,r,a,u))},N.prototype.setTree=function(e,t){return this._editable?(this._root=e,this._size=t,this):e===this._root?this:new N(this._editable,this._edit,this._config,e,t)};var k=n.tryGetHash=function(e,t,n,o){for(var r=o._root,a=0,i=o._config.keyEq;;)switch(r.type){case 1:return i(n,r.key)?r.value:e;case 2:if(t===r.hash)for(var s=r.children,u=0,c=s.length;u<c;++u){var h=s[u];if(i(n,h.key))return h.value}return e;case 3:var p=l(a,t),v=d(p);if(r.mask&v){r=r.children[f(r.mask,v)],a+=5;break}return e;case 4:if(r=r.children[l(a,t)]){a+=5;break}return e;default:return e}};N.prototype.tryGetHash=function(e,t,n){return k(e,t,n,this)};var V=n.tryGet=function(e,t,n){return k(e,n._config.hash(t),t,n)};N.prototype.tryGet=function(e,t){return V(e,t,this)};var L=n.getHash=function(e,t,n){return k(void 0,e,t,n)};N.prototype.getHash=function(e,t){return L(e,t,this)};n.get=function(e,t){return k(void 0,t._config.hash(e),e,t)};N.prototype.get=function(e,t){return V(t,e,this)};var M=n.has=function(e,t,n){return k(s,e,t,n)!==s};N.prototype.hasHash=function(e,t){return M(e,t,this)};var C=n.has=function(e,t){return M(t._config.hash(e),e,t)};N.prototype.has=function(e){return C(e,this)};var B=function(e,t){return e===t};n.make=function(e){return new N(0,0,{keyEq:e&&e.keyEq||B,hash:e&&e.hash||c},v,0)},n.empty=n.make();var U=n.isEmpty=function(e){return e&&!!y(e._root)};N.prototype.isEmpty=function(){return U(this)};var D=n.modifyHash=function(e,t,n,o){var r={value:o._size},a=o._root._modify(o._editable?o._edit:NaN,o._config.keyEq,0,e,t,n,r);return o.setTree(a,r.value)};N.prototype.modifyHash=function(e,t,n){return D(n,e,t,this)};var I=n.modify=function(e,t,n){return D(e,n._config.hash(t),t,n)};N.prototype.modify=function(e,t){return I(t,e,this)};var x=n.setHash=function(e,t,n,o){return D(u(n),e,t,o)};N.prototype.setHash=function(e,t,n){return x(e,t,n,this)};var F=n.set=function(e,t,n){return x(n._config.hash(e),e,t,n)};N.prototype.set=function(e,t){return F(e,t,this)};var O=u(s),z=n.removeHash=function(e,t,n){return D(O,e,t,n)};N.prototype.removeHash=N.prototype.deleteHash=function(e,t){return z(e,t,this)};var P=n.remove=function(e,t){return z(t._config.hash(e),e,t)};N.prototype.remove=N.prototype.delete=function(e){return P(e,this)};var G=n.beginMutation=function(e){return new N(e._editable+1,e._edit+1,e._config,e._root,e._size)};N.prototype.beginMutation=function(){return G(this)};var W=n.endMutation=function(e){return e._editable=e._editable&&e._editable-1,e};N.prototype.endMutation=function(){return W(this)};var q=n.mutate=function(e,t){var n=G(t);return e(n),W(n)};N.prototype.mutate=function(e){return q(e,this)};var j=function(e){return e&&H(e[0],e[1],e[2],e[3],e[4])},H=function(e,t,n,o,r){for(;n<e;){var a=t[n++];if(a&&!y(a))return $(a,o,[e,t,n,o,r])}return j(r)},$=function(e,t,n){switch(e.type){case 1:return{value:t(e),rest:n};case 2:case 4:case 3:var o=e.children;return H(o.length,o,0,t,n);default:return j(n)}},K={done:!0};function Z(e){this.v=e}Z.prototype.next=function(){if(!this.v)return K;var e=this.v;return this.v=j(e.rest),e},Z.prototype[Symbol.iterator]=function(){return this};var J=function(e,t){return new Z($(e._root,t))},X=function(e){return[e.key,e.value]},Q=n.entries=function(e){return J(e,X)};N.prototype.entries=N.prototype[Symbol.iterator]=function(){return Q(this)};var Y=function(e){return e.key},ee=n.keys=function(e){return J(e,Y)};N.prototype.keys=function(){return ee(this)};var te=function(e){return e.value},ne=n.values=N.prototype.values=function(e){return J(e,te)};N.prototype.values=function(){return ne(this)};var oe=n.fold=function(e,t,n){var o=n._root;if(1===o.type)return e(t,o.value,o.key);for(var r=[o.children],a=void 0;a=r.pop();)for(var i=0,s=a.length;i<s;){var u=a[i++];u&&u.type&&(1===u.type?t=e(t,u.value,u.key):r.push(u.children))}return t};N.prototype.fold=function(e,t){return oe(e,t,this)};var re=n.forEach=function(e,t){return oe((function(n,o,r){return e(o,r,t)}),null,t)};N.prototype.forEach=function(e){return re(e,this)};var ae=n.count=function(e){return e._size};N.prototype.count=function(){return ae(this)},Object.defineProperty(N.prototype,"size",{get:N.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n}));class Ie{constructor(e){T(this,"_map",void 0),this._map=new Map(null===e||void 0===e?void 0:e.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(e){return this._map.get(e)}has(e){return this._map.has(e)}set(e,t){return this._map.set(e,t),this}delete(e){return this._map.delete(e),this}clone(){return Fe(this)}toMap(){return new Map(this._map)}}class xe{constructor(e){if(T(this,"_hamt",De.empty.beginMutation()),e instanceof xe){const t=e._hamt.endMutation();e._hamt=t.beginMutation(),this._hamt=t.beginMutation()}else if(e)for(const[t,n]of e.entries())this._hamt.set(t,n)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(e){return this._hamt.get(e)}has(e){return this._hamt.has(e)}set(e,t){return this._hamt.set(e,t),this}delete(e){return this._hamt.delete(e),this}clone(){return Fe(this)}toMap(){return new Map(this._hamt)}}function Fe(e){return w("recoil_hamt_2020")?new xe(e):new Ie(e)}var Oe=Fe,ze=Object.freeze({__proto__:null,persistentMap:Oe});const{graph:Pe}=Ue,{persistentMap:Ge}=ze;let We=0;const qe=()=>We++;function je(){const e=qe();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:Ge(),nonvalidatedAtoms:Ge()}}var He={makeEmptyTreeState:je,makeEmptyStoreState:function(){const e=je();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(e.version,Pe()),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:qe};var $e=function(...e){const t=new Set;for(const n of e)for(const e of n)t.add(e);return t};var Ke=function(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1};const{cleanUpNode:Ze}=te,{deleteNodeConfigIfPossible:Je,getNode:Xe}=G,{RetentionZone:Qe}=q,Ye=new Set;function et(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return void y("releaseNodesNowOnCurrentTree should only be called at the end of a batch");const r=new Set;for(const i of t)if(i instanceof Qe)for(const e of nt(n,i))r.add(e);else r.add(i);const a=function(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,i=new Set;return s(t),a;function s(t){const c=new Set,l=function(e,t,n,o,r){const a=e.getGraph(t.version),i=[],s=new Set;for(;n.size>0;)c(u(n.values().next().value));return i;function c(e){if(o.has(e)||r.has(e))return void n.delete(e);if(s.has(e))return;const t=a.nodeToNodeSubscriptions.get(e);if(t)for(const n of t)c(n);s.add(e),n.delete(e),i.push(e)}}(e,o,t,a,i);for(const e of l){var d;if("recoilRoot"===Xe(e).retainedBy){i.add(e);continue}if((null!==(d=n.retention.referenceCounts.get(e))&&void 0!==d?d:0)>0){i.add(e);continue}if(ot(e).some(e=>n.retention.referenceCounts.get(e))){i.add(e);continue}const t=r.nodeToNodeSubscriptions.get(e);t&&Ke(t,e=>i.has(e))?i.add(e):(a.add(e),c.add(e))}const f=new Set;for(const e of c)for(const t of null!==(h=r.nodeDeps.get(e))&&void 0!==h?h:Ye){var h;a.has(t)||f.add(t)}f.size&&s(f)}}(e,r);for(const i of a)tt(e,o,i)}function tt(e,t,n){if(!w("recoil_memory_managament_2020"))return;Ze(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=ot(n);for(const u of r){var a;null===(a=o.retention.nodesRetainedByZone.get(u))||void 0===a||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const i=o.graphsByVersion.get(t.version);if(i){const e=i.nodeDeps.get(n);if(void 0!==e){i.nodeDeps.delete(n);for(const t of e){var s;null===(s=i.nodeToNodeSubscriptions.get(t))||void 0===s||s.delete(n)}}i.nodeToNodeSubscriptions.delete(n)}Je(n)}function nt(e,t){var n;return null!==(n=e.retention.nodesRetainedByZone.get(t))&&void 0!==n?n:Ye}function ot(e){const t=Xe(e).retainedBy;return void 0===t||"components"===t||"recoilRoot"===t?[]:t instanceof Qe?[t]:t}function rt(e,t){if(!w("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),function(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):et(e,new Set([t]))}(e,t)}var at={updateRetainCount:function(e,t,n){var o;if(!w("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=(null!==(o=r.get(t))&&void 0!==o?o:0)+n;0===a?rt(e,t):r.set(t,a)},updateRetainCountToZero:rt,releaseScheduledRetainablesNow:function(e){if(!w("recoil_memory_managament_2020"))return;const t=e.getState();et(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(e){return void 0===e?"recoilRoot":e}};var it=function*(e){for(const t of e)for(const e of t)yield e};var st={isSSR:"undefined"===typeof window,isReactNative:"undefined"!==typeof navigator&&"ReactNative"===navigator.product};const{isSSR:ut}=st,{batchUpdates:ct}=Ve,{initializeNodeIfNewToStore:lt,peekNodeInfo:dt}=te,{graph:ft}=Ue,{DEFAULT_VALUE:ht,recoilValues:pt,recoilValuesForKeys:vt}=G,{AbstractRecoilValue:yt,getRecoilValueAsLoadable:mt,setRecoilValue:_t,setUnvalidatedRecoilValue:gt}=we,{updateRetainCount:St,updateRetainCountToZero:wt}=at,{getNextTreeStateVersion:bt,makeEmptyStoreState:Rt}=He;class Tt{constructor(e){T(this,"_store",void 0),T(this,"_refCount",0),T(this,"getLoadable",e=>(this.checkRefCount_INTERNAL(),mt(this._store,e))),T(this,"getPromise",e=>(this.checkRefCount_INTERNAL(),this.getLoadable(e).toPromise())),T(this,"getNodes_UNSTABLE",e=>{if(this.checkRefCount_INTERNAL(),!0===(null===e||void 0===e?void 0:e.isModified)){if(!1===(null===e||void 0===e?void 0:e.isInitialized))return[];const t=this._store.getState().currentTree;return vt(t.dirtyAtoms)}const t=this._store.getState().knownAtoms,n=this._store.getState().knownSelectors;return null==(null===e||void 0===e?void 0:e.isInitialized)?pt.values():!0===e.isInitialized?vt(it([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):_(pt.values(),({key:e})=>!t.has(e)&&!n.has(e))}),T(this,"getInfo_UNSTABLE",({key:e})=>(this.checkRefCount_INTERNAL(),dt(this._store,this._store.getState().currentTree,e))),T(this,"map",e=>{this.checkRefCount_INTERNAL();const t=new Nt(this);return e(t),Et(t.getStore_INTERNAL())}),T(this,"asyncMap",async e=>{this.checkRefCount_INTERNAL();const t=new Nt(this);return await e(t),Et(t.getStore_INTERNAL())}),this._store={getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{const n=e.graphsByVersion;if(n.has(t))return u(n.get(t));const o=ft();return n.set(t,o),o},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw new Error("Cannot subscribe to Snapshots")}};for(const t of this._store.getState().nodeCleanupFunctions.keys())lt(this._store,e.currentTree,t,"get"),St(this._store,t,1);this.retain(),this.autorelease_INTERNAL()}retain(){if(!w("recoil_memory_managament_2020"))return()=>{};this._refCount++;let e=!1;return()=>{e||(e=!0,this.release_INTERNAL())}}autorelease_INTERNAL(){w("recoil_memory_managament_2020")&&(ut||window.setTimeout(()=>this.release_INTERNAL(),0))}release_INTERNAL(){w("recoil_memory_managament_2020")&&(this._refCount--,this._refCount)}checkRefCount_INTERNAL(){w("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this.getID_INTERNAL()}getID_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}}function At(e,t,n=!1){const o=e.getState(),r=n?bt():t.version;return{currentTree:n?{version:r,stateID:r,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()}:t,commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(r,e.getGraph(t.version)),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}function Et(e,t="current"){const n=e.getState(),o="current"===t?n.currentTree:u(n.previousTree);return new Tt(At(e,o))}class Nt extends Tt{constructor(e){super(At(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0)),T(this,"set",(e,t)=>{this.checkRefCount_INTERNAL();const n=this.getStore_INTERNAL();ct(()=>{St(n,e.key,1),_t(this.getStore_INTERNAL(),e,t)})}),T(this,"reset",e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();ct(()=>{St(t,e.key,1),_t(this.getStore_INTERNAL(),e,ht)})}),T(this,"setUnvalidatedAtomValues_DEPRECATED",e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();ct(()=>{for(const[n,o]of e.entries())St(t,n,1),gt(t,new yt(n),o)})})}}var kt={Snapshot:Tt,MutableSnapshot:Nt,freshSnapshot:function(e){const t=new Tt(Rt());return null!=e?t.map(e):t},cloneSnapshot:Et},Vt=kt.Snapshot,Lt=kt.MutableSnapshot,Mt=kt.freshSnapshot,Ct=kt.cloneSnapshot,Bt=Object.freeze({__proto__:null,Snapshot:Vt,MutableSnapshot:Lt,freshSnapshot:Mt,cloneSnapshot:Ct});const{getNextTreeStateVersion:Ut,makeEmptyStoreState:Dt}=He,{cleanUpNode:It,getDownstreamNodes:xt,setNodeValue:Ft,setUnvalidatedAtomValue_DEPRECATED:Ot}=te,{graph:zt}=Ue,{cloneGraph:Pt}=Ue,{applyAtomValueWrites:Gt}=we,{releaseScheduledRetainablesNow:Wt}=at,{freshSnapshot:qt}=Bt,{useCallback:jt,useContext:Ht,useEffect:$t,useMemo:Kt,useRef:Zt,useState:Jt}=i.a;function Xt(){throw new Error("This component must be used inside a <RecoilRoot> component.")}const Qt=Object.freeze({getState:Xt,replaceState:Xt,getGraph:Xt,subscribeToTransactions:Xt,addTransactionMetadata:Xt});let Yt=!1;function en(e){if(Yt)throw new Error("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(null===t.nextTree){w("recoil_memory_managament_2020")&&w("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&Wt(e);const n=t.currentTree.version,o=Ut();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,Pt(u(t.graphsByVersion.get(n))))}}const tn=i.a.createContext({current:Qt}),nn=()=>Ht(tn),on=i.a.createContext(null);function rn(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[n,a]of t.nodeTransactionSubscriptions)if(o.has(n))for(const[t,o]of a)o(e);for(const[n,o]of t.transactionSubscriptions)o(e);const r=xt(e,n,o);for(const e of r){const o=t.nodeToComponentSubscriptions.get(e);if(o)for(const[e,[t,r]]of o)r(n)}t.suspendedComponentResolvers.forEach(e=>e())}t.queuedComponentCallbacks_DEPRECATED.forEach(e=>e(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function an({setNotifyBatcherOfChange:e}){const t=nn(),[n,o]=Jt([]);return e(()=>o({})),$t(()=>{Le.enqueueExecution("Batcher",()=>{const e=t.current.getState();e.commitDepth++;try{const{nextTree:n}=e;if(null===n)return;e.previousTree=e.currentTree,e.currentTree=n,e.nextTree=null,rn(t.current);const o=u(e.previousTree).version;e.graphsByVersion.delete(o),e.previousTree=null,w("recoil_memory_managament_2020")&&Wt(t.current)}finally{e.commitDepth--}})}),$t(()=>()=>{e(()=>{})},[e]),null}let sn=0;function un({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){var r;let a;const s=Zt(null),c=jt(e=>{s.current=e},[s]),l=null!==(r=i.a.createMutableSource)&&void 0!==r?r:i.a.unstable_createMutableSource,d=null!==n&&void 0!==n?n:{getState:()=>a.current,replaceState:e=>{const t=f.current.getState();en(f.current);const n=u(t.nextTree);let o;try{Yt=!0,o=e(n)}finally{Yt=!1}o!==n&&(t.nextTree=o,u(s.current)())},getGraph:e=>{const t=a.current.graphsByVersion;if(t.has(e))return u(t.get(e));const n=zt();return t.set(e,n),n},subscribeToTransactions:(e,t)=>{if(null==t){const{transactionSubscriptions:t}=f.current.getState(),n=sn++;return t.set(n,e),{release:()=>{t.delete(n)}}}{const{nodeTransactionSubscriptions:n}=f.current.getState();n.has(t)||n.set(t,new Map);const o=sn++;return u(n.get(t)).set(o,e),{release:()=>{const e=n.get(t);e&&(e.delete(o),0===e.size&&n.delete(t))}}}},addTransactionMetadata:e=>{en(f.current);for(const t of Object.keys(e))u(f.current.getState().nextTree).transactionMetadata[t]=e[t]}},f=Zt(d);a=Zt(null!=e?function(e,t){const n=Dt();return t({set:(t,o)=>{const r=n.currentTree,a=Ft(e,r,t.key,o),i=new Set(a.keys()),s=r.nonvalidatedAtoms.clone();for(const e of i)s.delete(e);n.currentTree={...r,dirtyAtoms:$e(r.dirtyAtoms,i),atomValues:Gt(r.atomValues,a),nonvalidatedAtoms:s}},setUnvalidatedAtomValues:e=>{e.forEach((e,t)=>{n.currentTree=Ot(n.currentTree,t,e)})}}),n}(d,e):null!=t?function(e){return qt().map(e).getStore_INTERNAL().getState()}(t):Dt());const h=Kt(()=>l?l(a,()=>a.current.currentTree.version):null,[l,a]);return $t(()=>()=>{for(const e of f.current.getState().knownAtoms)It(f.current,e)},[]),i.a.createElement(tn.Provider,{value:f},i.a.createElement(on.Provider,{value:h},i.a.createElement(an,{setNotifyBatcherOfChange:c}),o))}var cn={useStoreRef:nn,useRecoilMutableSource:function(){const e=Ht(on);return null==e&&R("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e},RecoilRoot:function(e){const{override:t,...n}=e,o=nn();return!1===t&&o.current!==Qt?i.a.createElement(i.a.Fragment,null,e.children):i.a.createElement(un,n)},sendEndOfBatchNotifications_FOR_TESTING:rn};var ln=function(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n};var dn=function(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n};var fn=function(e,t){if(!e)throw new Error(t)};var hn,pn=function(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t};const vn=null!==(hn=i.a.useMutableSource)&&void 0!==hn?hn:i.a.unstable_useMutableSource;var yn={mutableSourceExists:function(){return vn&&!("undefined"!==typeof window&&window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE)},useMutableSource:vn};var mn=function(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0};const{useRef:_n}=i.a;var gn=function(){return _n(),"<component name not available>"};const{batchUpdates:Sn}=Ve,{DEFAULT_VALUE:wn,getNode:bn,nodes:Rn}=G,{useRecoilMutableSource:Tn,useStoreRef:An}=cn,{isRecoilValue:En}=B,{AbstractRecoilValue:Nn,getRecoilValueAsLoadable:kn,setRecoilValue:Vn,setRecoilValueLoadable:Ln,setUnvalidatedRecoilValue:Mn,subscribeToRecoilValue:Cn}=we,{updateRetainCount:Bn}=at,{RetentionZone:Un}=q,{Snapshot:Dn,cloneSnapshot:In}=Bt,{setByAddingToSet:xn}=m,{isSSR:Fn}=st,{mutableSourceExists:On,useMutableSource:zn}=yn,{useCallback:Pn,useEffect:Gn,useMemo:Wn,useRef:qn,useState:jn}=i.a;function Hn(e,t,n){if("hasValue"===e.state)return e.contents;if("loading"===e.state){throw new Promise(e=>{n.current.getState().suspendedComponentResolvers.add(e)})}throw"hasError"===e.state?e.contents:new Error(`Invalid value of loadable atom "${t.key}"`)}function $n(e){return w("recoil_memory_managament_2020")&&no(e),On()?function(e){const t=An(),n=Pn(()=>{const n=t.current,o=n.getState().currentTree;return kn(n,e,o)},[t,e]),o=Pn(()=>n(),[n]),r=gn(),a=Pn((o,a)=>{const i=t.current;return Cn(i,e,()=>{if(!w("recoil_suppress_rerender_in_callback"))return a();const e=n();u.current.is(e)||a(),u.current=e},r).release},[t,e,r,n]),i=Tn(),s=zn(i,o,a),u=qn(s);return Gn(()=>{u.current=s}),s}(e):function(e){const t=An(),[n,o]=jn([]),r=gn();Gn(()=>{const n=t.current,a=n.getState(),s=Cn(n,e,t=>{var r;if(!w("recoil_suppress_rerender_in_callback"))return o([]);const a=kn(n,e,n.getState().currentTree);(null===(r=i.current)||void 0===r?void 0:r.is(a))||o(a),i.current=a},r);if(a.nextTree)n.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{i.current=null,o([])});else{var u;if(!w("recoil_suppress_rerender_in_callback"))return o([]);const t=kn(n,e,n.getState().currentTree);(null===(u=i.current)||void 0===u?void 0:u.is(t))||o(t),i.current=t}return s.release},[r,e,t]);const a=kn(t.current,e),i=qn(a);return Gn(()=>{i.current=a}),a}(e)}function Kn(e){const t=An();return Hn($n(e),e,t)}function Zn(e){const t=An();return Pn(n=>{Vn(t.current,e,n)},[t,e])}function Jn(e){const t=An();Gn(()=>t.current.subscribeToTransactions(e).release,[e,t])}function Xn(e){const t=e.atomValues.toMap(),n=Ce(ln(t,(e,t)=>{const n=bn(t).persistence_UNSTABLE;return null!=n&&"none"!==n.type&&"hasValue"===e.state}),e=>e.contents);return pn(e.nonvalidatedAtoms.toMap(),n)}function Qn(e){const t=qn();return Gn(()=>{t.current=e}),t.current}function Yn(){const e=An();return Pn(t=>{var n;const o=e.current.getState(),r=null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;Sn(()=>{const n=new Set;for(const e of[r.atomValues.keys(),a.atomValues.keys()])for(const t of e){var o,i;(null===(o=r.atomValues.get(t))||void 0===o?void 0:o.contents)!==(null===(i=a.atomValues.get(t))||void 0===i?void 0:i.contents)&&bn(t).shouldRestoreFromSnapshots&&n.add(t)}n.forEach(t=>{Ln(e.current,new Nn(t),a.atomValues.has(t)?u(a.atomValues.get(t)):wn)}),e.current.replaceState(e=>({...e,stateID:t.getID_INTERNAL()}))})},[e])}class eo{}const to=new eo;function no(e){if(w("recoil_memory_managament_2020"))return function(e){const t=(Array.isArray(e)?e:[e]).map(e=>e instanceof Un?e:e.key),n=An();Gn(()=>{if(!w("recoil_memory_managament_2020"))return;const e=n.current;if(o.current&&!Fn)window.clearTimeout(o.current),o.current=null;else{y("Did not retain recoil value on render, or committed after timeout elapsed. This is fine, but odd.");for(const n of t)Bn(e,n,1)}return()=>{for(const n of t)Bn(e,n,-1)}},[n,...t]);const o=qn(),r=Qn(t);if(!Fn&&(void 0===r||!mn(r,t))){const e=n.current;for(const n of t)Bn(e,n,1);if(r)for(const t of r)Bn(e,t,-1);o.current&&window.clearTimeout(o.current),o.current=window.setTimeout(()=>{o.current=null;for(const n of t)Bn(e,n,-1)},12e4)}}(e)}var oo={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useGotoRecoilSnapshot:Yn,useRecoilCallback:function(e,t){const n=An(),o=Yn();return Pn((...t)=>{function r(e,t){Vn(n.current,e,t)}function a(e){Vn(n.current,e,wn)}const i=In(n.current);let s=to;return Sn(()=>{const n="useRecoilCallback expects a function that returns a function: it accepts a function of the type (RecoilInterface) => T = R and returns a callback function T => R, where RecoilInterface is an object {snapshot, set, ...} and T and R are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!==typeof e)throw new Error(n);const u=e({set:r,reset:a,snapshot:i,gotoSnapshot:o});if("function"!==typeof u)throw new Error(n);s=u(...t)}),s instanceof eo&&fn(!1),s},null!=t?[...t,n]:void 0)},useRecoilInterface:function(){const e=An(),[t,n]=jn([]),o=qn(new Set);o.current=new Set;const r=qn(new Set),a=qn(new Map),i=Pn(e=>{const t=a.current.get(e);t&&(t.release(),a.current.delete(e))},[a]),s=gn();return Gn(()=>{const t=e.current;function u(e,t){a.current.has(t)&&n([])}Me(o.current,r.current).forEach(e=>{if(a.current.has(e))return void R(`Double subscription to RecoilValue "${e}"`);const n=Cn(t,new Nn(e),t=>{u(0,e)},s);a.current.set(e,n);t.getState().nextTree?t.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{u(t.getState(),e)}):u(t.getState(),e)}),Me(r.current,o.current).forEach(e=>{i(e)}),r.current=o.current}),Gn(()=>{const e=a.current;return()=>e.forEach((e,t)=>i(t))},[i]),Wn(()=>{function t(t){return n=>{Vn(e.current,t,n)}}function n(t){return o.current.has(t.key)||(o.current=xn(o.current,t.key)),kn(e.current,t)}function r(t){return Hn(n(t),t,e)}return{getRecoilValue:r,getRecoilValueLoadable:n,getRecoilState:function(e){return[r(e),t(e)]},getRecoilStateLoadable:function(e){return[n(e),t(e)]},getSetRecoilState:t,getResetRecoilState:function(t){return()=>Vn(e.current,t,wn)}}},[o,e])},useRecoilSnapshot:function(){const e=An(),[t,n]=jn(()=>In(e.current)),o=Qn(t),r=qn();return Gn(()=>(r.current&&!Fn&&window.clearTimeout(r.current),t.retain()),[t]),Jn(Pn(e=>n(In(e)),[])),o===t||Fn||(r.current&&(null===o||void 0===o||o.release_INTERNAL(),window.clearTimeout(r.current)),t.retain(),r.current=window.setTimeout(()=>{t.release_INTERNAL(),r.current=null},12e4)),t},useRecoilState:function(e){return[Kn(e),Zn(e)]},useRecoilStateLoadable:function(e){return[$n(e),Zn(e)]},useRecoilTransactionObserver:function(e){Jn(Pn(t=>{const n=In(t,"current"),o=In(t,"previous");e({snapshot:n,previousSnapshot:o})},[e]))},useRecoilValue:Kn,useRecoilValueLoadable:$n,useRetain:no,useResetRecoilState:function(e){const t=An();return Pn(()=>{Vn(t.current,e,wn)},[t,e])},useSetRecoilState:Zn,useSetUnvalidatedAtomValues:function(){const e=An();return(t,n={})=>{Sn(()=>{e.current.addTransactionMetadata(n),t.forEach((t,n)=>Mn(e.current,new Nn(n),t))})}},useTransactionObservation_DEPRECATED:function(e){Jn(Pn(t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(y("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);const r=Xn(o),a=Xn(n),i=Ce(Rn,e=>{var t,n,o,r;return{persistence_UNSTABLE:{type:null!==(t=null===(n=e.persistence_UNSTABLE)||void 0===n?void 0:n.type)&&void 0!==t?t:"none",backButton:null!==(o=null===(r=e.persistence_UNSTABLE)||void 0===r?void 0:r.backButton)&&void 0!==o&&o}}}),s=dn(o.dirtyAtoms,e=>r.has(e)||a.has(e));e({atomValues:r,previousAtomValues:a,atomInfo:i,modifiedAtoms:s,transactionMetadata:{...o.transactionMetadata}})},[e]))},useTransactionSubscription_DEPRECATED:Jn};const{peekNodeInfo:ro}=te,{useStoreRef:ao}=cn;var io=function(){const e=ao();return({key:t})=>ro(e.current,e.current.getState().currentTree,t)};const{RecoilRoot:so,useStoreRef:uo}=cn,{useMemo:co}=i.a;var lo=function(){const e=uo().current;return co(()=>function({children:t}){return i.a.createElement(so,{store_INTERNAL:e},t)},[e])};const{isReactNative:fo,isSSR:ho}=st;var po=function(e,t={allowFunctions:!1}){return function e(t,n,o){if("string"===typeof t&&!t.includes('"')&&!t.includes("\\"))return`"${t}"`;switch(typeof t){case"undefined":return"";case"boolean":return t?"true":"false";case"number":case"symbol":return String(t);case"string":return JSON.stringify(t);case"function":if(!0!==(null===n||void 0===n?void 0:n.allowFunctions))throw new Error("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${t.name})__`}if(null===t)return"null";var r;if("object"!==typeof t)return null!==(r=JSON.stringify(t))&&void 0!==r?r:"";if(s(t))return"__PROMISE__";if(Array.isArray(t))return`[${t.map((t,o)=>e(t,n,o.toString()))}]`;if("function"===typeof t.toJSON)return e(t.toJSON(o),n,o);if(t instanceof Map){const r={};for(const[o,a]of t)r["string"===typeof o?o:e(o,n)]=a;return e(r,n,o)}return t instanceof Set?e(Array.from(t).sort((t,o)=>e(t,n).localeCompare(e(o,n))),n,o):void 0!==Symbol&&null!=t[Symbol.iterator]&&"function"===typeof t[Symbol.iterator]?e(Array.from(t),n,o):`{${Object.keys(t).filter(e=>void 0!==t[e]).sort().map(o=>`${e(o,n)}:${e(t[o],n,o)}`).join(",")}}`}(e,t)};const vo=(e,t,n)=>{var o;if(null==e)return;if(null===n||void 0===n||null===(o=n.onNodeVisit)||void 0===o||o.call(n,e),"leaf"===e.type)return e;const r=t(e.nodeKey);return vo(e.branches.get(r),t,n)},yo=(e,t,n,o,r,a)=>{var i;let s;if(null==e)if(0===t.length)s={type:"leaf",value:o,parent:n,branchKey:r};else{const[e,...i]=t,[u,c]=e;s={type:"branch",nodeKey:u,parent:n,branches:new Map,branchKey:r},s.branches.set(c,yo(null,i,s,o,c,a))}else if(s=e,t.length){const[n,...r]=t,[i,s]=n;("branch"!==e.type||e.nodeKey!==i)&&fn(!1),e.branches.set(s,yo(e.branches.get(s),r,e,o,s,a))}return null===a||void 0===a||null===(i=a.onNodeVisit)||void 0===i||i.call(a,s),s},mo=(e,t,n)=>n?(n.branches.delete(t.branchKey),_o(e,n,n.parent)):e===t,_o=(e,t,n)=>n?(0===t.branches.size&&n.branches.delete(t.branchKey),_o(e,n,n.parent)):e===t,go=e=>"leaf"===e.type?1:Array.from(e.branches.values()).reduce((e,t)=>e+go(t),0);var So=class{constructor(e){var t,n,o;T(this,"_numLeafs",void 0),T(this,"_root",void 0),T(this,"_onHit",void 0),T(this,"_onSet",void 0),T(this,"_mapNodeValue",void 0),this._numLeafs=0,this._root=null,this._onHit=null!==(t=null===e||void 0===e?void 0:e.onHit)&&void 0!==t?t:()=>{},this._onSet=null!==(n=null===e||void 0===e?void 0:e.onSet)&&void 0!==n?n:()=>{},this._mapNodeValue=null!==(o=null===e||void 0===e?void 0:e.mapNodeValue)&&void 0!==o?o:e=>e}size(){return this._numLeafs}root(){return this._root}get(e,t){var n;return null===(n=this.getLeafNode(e,t))||void 0===n?void 0:n.value}getLeafNode(e,t){return vo(this.root(),t=>this._mapNodeValue(e(t)),{onNodeVisit:e=>{null===t||void 0===t||t.onNodeVisit(e),"leaf"===e.type&&this._onHit(e)}})}set(e,t,n){let o;const r=yo(this.root(),e.map(([e,t])=>[e,this._mapNodeValue(t)]),null,t,null,{onNodeVisit:e=>{null===n||void 0===n||n.onNodeVisit(e),"leaf"===e.type&&(o=e)}});this.root()||(this._root=r),this._numLeafs++,this._onSet(u(o))}delete(e){if(!this.root())return!1;const t=u(this.root());return!!mo(t,e,e.parent)&&(e===t||"branch"===t.type&&!t.branches.size?(this._root=null,this._numLeafs=0,!0):(this._numLeafs-=go(e),!0))}clear(){this._numLeafs=0,this._root=null}},wo=Object.freeze({__proto__:null,TreeCache:So});var bo=class{constructor(e){var t;T(this,"_maxSize",void 0),T(this,"_size",void 0),T(this,"_head",void 0),T(this,"_tail",void 0),T(this,"_map",void 0),T(this,"_keyMapper",void 0),this._maxSize=e.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(t=e.mapKey)&&void 0!==t?t:e=>e}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(e){return this._map.has(this._keyMapper(e))}get(e){const t=this._keyMapper(e),n=this._map.get(t);if(n)return this.set(e,n.value),n.value}set(e,t){const n=this._keyMapper(e);this._map.get(n)&&this.delete(e);const o=this.head(),r={key:e,right:o,left:null,value:t};o?o.left=r:this._tail=r,this._map.set(n,r),this._head=r,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const e=this.tail();e&&this.delete(e.key)}delete(e){const t=this._keyMapper(e);if(!this._size||!this._map.has(t))return;const n=u(this._map.get(t)),o=n.right,r=n.left;o&&(o.left=n.left),r&&(r.right=n.right),n===this.head()&&(this._head=o),n===this.tail()&&(this._tail=r),this._map.delete(t),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},Ro=Object.freeze({__proto__:null,LRUCache:bo});const{LRUCache:To}=Ro,{TreeCache:Ao}=wo;var Eo=function(e,t=(e=>e)){const n=new To({maxSize:e}),o=new Ao({mapNodeValue:t,onHit:e=>{n.set(e,!0)},onSet:t=>{const r=n.tail();n.set(t,!0),r&&o.size()>e&&o.delete(r.key)}});return o};const{TreeCache:No}=wo,ko={equality:"reference",eviction:"none",maxSize:1/0};var Vo=function({equality:e=ko.equality,eviction:t=ko.eviction,maxSize:n=ko.maxSize}=ko){return function(e,t,n){switch(e){case"none":return new No({mapNodeValue:n});case"lru":return Eo(u(t),n)}throw new Error("Unrecognized eviction policy "+e)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>po(e)}throw new Error("Unrecognized equality policy "+e)}(e))};var Lo={startPerfBlock:function(e){return()=>null}};const{CANCELED:Mo,Canceled:Co,loadableWithError:Bo,loadableWithPromise:Uo,loadableWithValue:Do}=v,{getNodeLoadable:Io,peekNodeLoadable:xo,setNodeValue:Fo}=te,{saveDependencyMapToStore:Oo}=Ue,{DEFAULT_VALUE:zo,RecoilValueNotReady:Po,getConfigDeletionHandler:Go,registerNode:Wo}=G,{isRecoilValue:qo}=B,{AbstractRecoilValue:jo}=B,{setRecoilValueLoadable:Ho}=we,{retainedByOptionWithDefault:$o}=at,{cloneSnapshot:Ko}=Bt,{startPerfBlock:Zo}=Lo,Jo=[],Xo=new Map,Qo=(()=>{let e=0;return()=>e++})();var Yo=function(e){const{key:t,get:n,cachePolicy_UNSTABLE:o}=e,r=null!=e.set?e.set:void 0,a=Vo(null!==o&&void 0!==o?o:{equality:"reference",eviction:"none"}),i=$o(e.retainedBy_UNSTABLE),c=new Map;let l=0;function d(){return!w("recoil_memory_managament_2020")||l>0}function f(e){return c.has(e)||c.set(e,{depValuesDiscoveredSoFarDuringAsyncWork:null,latestLoadable:null,latestExecutionId:null,stateVersion:null}),u(c.get(e))}function h(e){return l++,e.getState().knownSelectors.add(t),()=>{l--,e.getState().knownSelectors.delete(t),c.delete(e)}}function p(){return void 0!==Go(t)&&!d()}function v(e,t,n){if("loading"===t.state){let t=Xo.get(n);null==t&&Xo.set(n,t=new Set),t.add(e)}}function m(e,t,n){if(t.atomValues.has(n))return u(t.atomValues.get(n));const o=Io(e,t,n),r=e.getState().knownSelectors.has(n);return"loading"!==o.state&&r&&t.atomValues.set(n,o),o}function _(e,n,o,r,a){return n.then(n=>{if(!d())return V(e,a),Mo;if(n instanceof Co)return y("Selector was released while it had dependencies"),Mo;const{__key:r,__value:i}=null!==n&&void 0!==n?n:{};let s=!0;null!=r&&(o.atomValues.set(r,Do(i)),s=!1);const[u,c]=b(e,o,a,s);if(L(e,a)&&k(c,e,a),M(u),"loading"!==u.state&&(B(o,R(c),u),S(e,o,new Set(c.keys()),a),g(e,u,a)),"hasError"===u.state)throw u.contents;return"hasValue"===u.state?{__value:u.contents,__key:t}:u.contents}).catch(t=>{if(!d())return V(e,a),Mo;const n=Bo(t);throw C(t),B(o,R(r),Bo(t)),S(e,o,new Set(r.keys()),a),g(e,n,a),t})}function g(e,n,o){L(e,o)&&(N(n,e),function(e,n){const o=Xo.get(n);if(void 0!==o){for(const n of o)Ho(n,new jo(t),e);Xo.delete(n)}}(n,o))}function S(e,n,o,r){var a,i,s,u,c,l,d;(L(e,r)||n.version===(null===(a=e.getState())||void 0===a||null===(i=a.currentTree)||void 0===i?void 0:i.version)||n.version===(null===(s=e.getState())||void 0===s||null===(u=s.nextTree)||void 0===u?void 0:u.version))&&Oo(new Map([[t,o]]),e,null!==(c=null===(l=e.getState())||void 0===l||null===(d=l.nextTree)||void 0===d?void 0:d.version)&&void 0!==c?c:e.getState().currentTree.version)}function b(e,o,r,a=!1){const i=Zo(t);let u,c,l=!1;const f=new Map,h=new Set;function p(t){const{key:n}=t;!function(e,t,n,o,r){n.add(o),S(e,t,n,r)}(e,o,h,n,r);const i=a?Io(e,o,n):m(e,o,n);if(M(i),f.set(n,i),"hasValue"===i.state)return i.contents;throw i.contents}S(e,o,h,r);let v=!1;const y=t=>(...n)=>{if(!v)throw new Error("getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can obtain the current Recoil state without a subscription.");const o=Ko(e),r=t({snapshot:o});if("function"!==typeof r)throw new Error("getCallback() expects a function that returns a function.");return r(...n)};try{u=n({get:p,getCallback:y}),u=qo(u)?p(u):u,v=!0,s(u)?u=function(e,n,o,r,a){return n.then(n=>{if(!d())return V(e,a),Mo;const i=Do(n);return C(n),B(o,R(r),i),S(e,o,new Set(r.keys()),a),g(e,i,a),{__value:n,__key:t}}).catch(t=>{if(!d())return V(e,a),Mo;if(L(e,a)&&k(r,e,a),s(t))return _(e,t,o,r,a);const n=Bo(t);throw C(t),B(o,R(r),n),S(e,o,new Set(r.keys()),a),g(e,n,a),t})}(e,u,o,f,r).finally(i):i()}catch(w){u=w,s(u)?u=_(e,u,o,f,r).finally(i):(l=!0,i())}return c=l?Bo(u):s(u)?Uo(u):Do(u),M(c),[c,f]}function R(e){return Array.from(e.entries()).map(([e,t])=>[e,t.contents])}function T(e,t){const n=Qo(),[o,r]=b(e,t,n);return N(o,e,r,n,t),function(e,t,n){"loading"!==n.state&&B(e,t,n)}(t,R(r),o),v(e,o,n),o}function A(e,n){const o=function(e,n){const o=new Set,r=f(e),i=a.get(t=>("string"!==typeof t&&fn(!1),m(e,n,t).contents),{onNodeVisit:e=>{"branch"===e.type&&e.nodeKey!==t&&"string"===typeof e.nodeKey&&o.add(e.nodeKey)}});return i&&S(e,n,o,r.latestExecutionId),i}(e,n);if(null!=o)return N(o,e),o;const r=function(e,t){var n;const[,o]=null!==(n=Array.from(c.entries()).find(([,n])=>null!=n.latestLoadable&&null!=n.latestExecutionId&&!function(e,t){var n,o;const r=f(e),a=null!==(n=r.depValuesDiscoveredSoFarDuringAsyncWork)&&void 0!==n?n:new Map,i=Array((null!==(o=E.get(t.version))&&void 0!==o?o:new Map).entries()),s=E.has(t.version)&&i.length===a.size&&i.every(([e,t])=>a.get(e)===t);if(null==a||t.version===r.stateVersion||s)return!1;return E.set(t.version,new Map(a)),Array.from(a).some(([n,o])=>{const r=m(e,t,n);return r.contents!==o.contents&&!("loading"===o.state&&"loading"!==r.state)})}(e,t)))&&void 0!==n?n:[];return o}(e,n);if(r){const t=r;return v(e,u(t.latestLoadable),u(t.latestExecutionId)),u(t.latestLoadable)}return T(e,n)}const E=new Map;function N(e,t,n,o,r){const a=f(t);"loading"===e.state?(a.depValuesDiscoveredSoFarDuringAsyncWork=n,a.latestExecutionId=o,a.latestLoadable=e,a.stateVersion=null===r||void 0===r?void 0:r.version):(a.depValuesDiscoveredSoFarDuringAsyncWork=null,a.latestExecutionId=null,a.latestLoadable=null,a.stateVersion=null)}function k(e,t,n){const o=f(t);L(t,n)&&(o.depValuesDiscoveredSoFarDuringAsyncWork=e)}function V(e,t){L(e,t)&&c.delete(e)}function L(e,t){return t===f(e).latestExecutionId}function M(e){"loading"!==e.state&&C(e.contents)}function C(e){0}function B(e,n,o){e.atomValues.set(t,o),a.set(n,o)}function U(e,t){return a.get(n=>{"string"!==typeof n&&fn(!1);const o=xo(e,t,n);return null===o||void 0===o?void 0:o.contents})}function D(e,n){return function(e){if(Jo.includes(t)){const e="Recoil selector has circular dependencies: "+Jo.slice(Jo.indexOf(t)).join(" \u2192 ");return Bo(new Error(e))}Jo.push(t);try{return e()}finally{Jo.pop()}}(()=>A(e,n))}function I(e){e.atomValues.delete(t)}if(null!=r){return Wo({key:t,peek:U,get:D,set:(e,t,n)=>{let o=!1;const a=new Map;function i({key:n}){if(o)throw new Error("Recoil: Async selector sets are not currently supported.");const r=m(e,t,n);if(M(r),"hasValue"===r.state)return r.contents;throw"loading"===r.state?new Po(n):r.contents}function u(n,r){if(o)throw new Error("Recoil: Async selector sets are not currently supported.");const s="function"===typeof r?r(i(n)):r;Fo(e,t,n.key,s).forEach((e,t)=>a.set(t,e))}const c=r({set:u,get:i,reset:function(e){u(e,zo)}},n);if(void 0!==c)throw s(c)?new Error("Recoil: Async selector sets are not currently supported."):new Error("Recoil: selector set should be a void function.");return o=!0,a},init:h,invalidate:I,shouldDeleteConfigOnRelease:p,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:i})}return Wo({key:t,peek:U,get:D,init:h,invalidate:I,shouldDeleteConfigOnRelease:p,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:i})};const{loadableWithError:er,loadableWithPromise:tr,loadableWithValue:nr}=v,{DEFAULT_VALUE:or,DefaultValue:rr,getConfigDeletionHandler:ar,registerNode:ir,setConfigDeletionHandler:sr}=G,{isRecoilValue:ur}=B,{markRecoilValueModified:cr,setRecoilValue:lr,setRecoilValueLoadable:dr}=we,{retainedByOptionWithDefault:fr}=at;function hr(e){const{key:t,persistence_UNSTABLE:n}=e,o=fr(e.retainedBy_UNSTABLE);let r=0,a=s(e.default)?tr(e.default.then(e=>{a=nr(e);return{__key:t,__value:e}}).catch(e=>{throw a=er(e),e})):nr(e.default),i=void 0;const c=new Map;const l=ir({key:t,peek:function(e,n){var o,r,s;return null!==(o=null!==(r=n.atomValues.get(t))&&void 0!==r?r:null===(s=i)||void 0===s?void 0:s[1])&&void 0!==o?o:a},get:function(e,o){if(o.atomValues.has(t))return u(o.atomValues.get(t));if(o.nonvalidatedAtoms.has(t)){if(null!=i)return i;if(null==n)return R(`Tried to restore a persisted value for atom ${t} but it has no persistence settings.`),a;const e=o.nonvalidatedAtoms.get(t),r=n.validator(e,or),s=r instanceof rr?a:nr(r);return i=s,i}return a},set:function(e,n,o){if(n.atomValues.has(t)){const e=u(n.atomValues.get(t));if("hasValue"===e.state&&o===e.contents)return new Map}else if(!n.nonvalidatedAtoms.has(t)&&o instanceof rr)return new Map;return i=void 0,(new Map).set(t,nr(o))},init:function(n,o,i){r++;const u=n.getState().knownAtoms.has(t);if(n.getState().knownAtoms.add(t),"loading"===a.state){const e=()=>{var e;(null!==(e=n.getState().nextTree)&&void 0!==e?e:n.getState().currentTree).atomValues.has(t)||cr(n,l)};a.contents.then(e).catch(e)}let d=or,f=null;if(null!=e.effects_UNSTABLE&&!u){let o=!0;const r=e=>t=>{if(o){const n=d instanceof rr||s(d)?"hasValue"===a.state?a.contents:or:d;d="function"===typeof t?t(n):t,s(d)&&(d=d.then(t=>(f={effect:e,value:t},t)))}else{if(s(t))throw new Error("Setting atoms to async values is not implemented.");"function"!==typeof t&&(f={effect:e,value:t}),lr(n,l,"function"===typeof t?n=>{const o=t(n);return f={effect:e,value:o},o}:t)}},u=e=>()=>r(e)(or),p=e=>o=>{n.subscribeToTransactions(n=>{let{currentTree:r,previousTree:i}=n.getState();i||(y("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),i=r);const s=r.atomValues.get(t);if(null==s||"hasValue"===s.state){var u,c,l,d;const n=null!=s?s.contents:or,r=null!==(u=i.atomValues.get(t))&&void 0!==u?u:a,h="hasValue"===r.state?r.contents:or;(null===(c=f)||void 0===c?void 0:c.effect)!==e||(null===(l=f)||void 0===l?void 0:l.value)!==n?o(n,h):(null===(d=f)||void 0===d?void 0:d.effect)===e&&(f=null)}},t)};for(const t of null!==(h=e.effects_UNSTABLE)&&void 0!==h?h:[]){var h;const e=t({node:l,trigger:i,setSelf:r(t),resetSelf:u(t),onSet:p(t)});null!=e&&c.set(n,e)}o=!1}if(!(d instanceof rr)){var p;const e=s(d)?tr(function(e,n){const o=n.then(n=>{var r,a;return(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&lr(e,l,n),{__key:t,__value:n}}).catch(n=>{var r,a;throw(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&dr(e,l,er(n)),n});return o}(n,d)):nr(d);o.atomValues.set(t,e),null===(p=n.getState().nextTree)||void 0===p||p.atomValues.set(t,e)}return()=>{var e;r--,null===(e=c.get(n))||void 0===e||e(),c.delete(n),n.getState().knownAtoms.delete(t)}},invalidate:function(){i=void 0},shouldDeleteConfigOnRelease:function(){return void 0!==ar(t)&&r<=0},dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return l}function pr(e){const{default:t,...n}=e;return ur(t)?function(e){const t=pr({...e,default:or,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof rr?t:u(e.persistence_UNSTABLE).validator(t,or)},effects_UNSTABLE:e.effects_UNSTABLE}),n=Yo({key:e.key+"__withFallback",get:({get:n})=>{const o=n(t);return o instanceof rr?e.default:o},set:({set:e},n)=>e(t,n),dangerouslyAllowMutability:e.dangerouslyAllowMutability});return sr(n.key,ar(e.key)),n}({...n,default:t}):hr({...n,default:t})}var vr=pr;var yr=class{constructor(e){var t;T(this,"_map",void 0),T(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(t=null===e||void 0===e?void 0:e.mapKey)&&void 0!==t?t:e=>e}size(){return this._map.size}has(e){return this._map.has(this._keyMapper(e))}get(e){return this._map.get(this._keyMapper(e))}set(e,t){this._map.set(this._keyMapper(e),t)}delete(e){this._map.delete(this._keyMapper(e))}clear(){this._map.clear()}},mr=Object.freeze({__proto__:null,MapCache:yr});const{LRUCache:_r}=Ro,{MapCache:gr}=mr,Sr={equality:"reference",eviction:"none",maxSize:1/0};var wr=function({equality:e=Sr.equality,eviction:t=Sr.eviction,maxSize:n=Sr.maxSize}=Sr){return function(e,t,n){switch(e){case"none":return new gr({mapKey:n});case"lru":return new _r({mapKey:n,maxSize:u(t)})}throw new Error("Unrecognized eviction policy "+e)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>po(e)}throw new Error("Unrecognized equality policy "+e)}(e))};const{setConfigDeletionHandler:br}=G;var Rr=function(e){var t;const n=wr(null!==(t=e.cachePolicyForParams_UNSTABLE)&&void 0!==t?t:{equality:"value",eviction:"none"});return t=>{var o;const r=n.get(t);if(null!=r)return r;const{cachePolicyForParams_UNSTABLE:a,...i}=e,s=vr({...i,key:`${e.key}__${null!==(o=po(t))&&void 0!==o?o:"void"}`,default:"function"===typeof e.default?e.default(t):e.default,retainedBy_UNSTABLE:"function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE,effects_UNSTABLE:"function"===typeof e.effects_UNSTABLE?e.effects_UNSTABLE(t):e.effects_UNSTABLE});return n.set(t,s),br(s.key,()=>{n.delete(t)}),s}};const{setConfigDeletionHandler:Tr}=G;let Ar=0;var Er=function(e){var t;const n=wr(null!==(t=e.cachePolicyForParams_UNSTABLE)&&void 0!==t?t:{equality:"value",eviction:"none"});return t=>{var o;const r=n.get(t);if(null!=r)return r;const a=`${e.key}__selectorFamily/${null!==(o=po(t,{allowFunctions:!0}))&&void 0!==o?o:"void"}/${Ar++}`,i=n=>e.get(t)(n),s=e.cachePolicy_UNSTABLE,u="function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE;let c;if(null!=e.set){const n=e.set;c=Yo({key:a,get:i,set:(e,o)=>n(t)(e,o),cachePolicy_UNSTABLE:s,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u})}else c=Yo({key:a,get:i,cachePolicy_UNSTABLE:s,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u});return n.set(t,c),Tr(c.key,()=>{n.delete(t)}),c}};const Nr=Er({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});var kr=function(e){return Nr(e)};const Vr=Er({key:"__error",get:e=>()=>{throw new Error(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Lr=function(e){return Vr(e)};var Mr=function(e){return e};const{loadableWithError:Cr,loadableWithPromise:Br,loadableWithValue:Ur}=v;function Dr(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[a,i]of t.entries())try{n[a]=e(i)}catch(r){o[a]=r}return[n,o]}function Ir(e){return null!=e&&!s(e)}function xr(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function Fr(e){return null!=e&&"object"===typeof e&&e.hasOwnProperty("__value")?e.__value:e}function Or(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((e,n,o)=>({...e,[n]:t[o]}),{})}function zr(e,t,n){return Or(e,n.map((e,n)=>null==e?Ur(t[n]):s(e)?Br(e):Cr(e)))}var Pr={waitForNone:Er({key:"__waitForNone",get:e=>({get:t})=>{const n=xr(e),[o,r]=Dr(t,n);return zr(e,o,r)}}),waitForAny:Er({key:"__waitForAny",get:e=>({get:t})=>{const n=xr(e),[o,r]=Dr(t,n);return r.some(e=>!s(e))?zr(e,o,r):new Promise(t=>{for(const[n,a]of r.entries())s(a)&&a.then(a=>{o[n]=Fr(a),r[n]=void 0,t(zr(e,o,r))}).catch(a=>{r[n]=a,t(zr(e,o,r))})})}}),waitForAll:Er({key:"__waitForAll",get:e=>({get:t})=>{const n=xr(e),[o,r]=Dr(t,n);if(r.every(e=>null==e))return Or(e,o);const a=r.find(Ir);if(null!=a)throw a;return Promise.all(r).then(t=>{return Or(e,(n=o,r=t,r.map((e,t)=>void 0===e?n[t]:e)).map(Fr));var n,r})}}),waitForAllSettled:Er({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=xr(e),[o,r]=Dr(t,n);return r.every(e=>!s(e))?zr(e,o,r):Promise.all(r.map((e,t)=>s(e)?e.then(e=>{o[t]=Fr(e),r[t]=void 0}).catch(e=>{o[t]=void 0,r[t]=e}):null)).then(()=>zr(e,o,r))}}),noWait:Er({key:"__noWait",get:e=>({get:t})=>{try{return Ur(t(e))}catch(n){return s(n)?Br(n):Cr(n)}}})};const{batchUpdates:Gr,setBatcher:Wr}=Ve,{DefaultValue:qr}=G,{RecoilRoot:jr}=cn,{isRecoilValue:Hr}=B,{retentionZone:$r}=q,{freshSnapshot:Kr}=Bt,{useGotoRecoilSnapshot:Zr,useRecoilCallback:Jr,useRecoilSnapshot:Xr,useRecoilState:Qr,useRecoilStateLoadable:Yr,useRecoilTransactionObserver:ea,useRecoilValue:ta,useRecoilValueLoadable:na,useResetRecoilState:oa,useRetain:ra,useSetRecoilState:aa,useSetUnvalidatedAtomValues:ia,useTransactionObservation_DEPRECATED:sa}=oo,{noWait:ua,waitForAll:ca,waitForAllSettled:la,waitForAny:da,waitForNone:fa}=Pr;var ha={DefaultValue:qr,RecoilRoot:jr,useRecoilBridgeAcrossReactRoots_UNSTABLE:lo,atom:vr,selector:Yo,retentionZone:$r,atomFamily:Rr,selectorFamily:Er,constSelector:kr,errorSelector:Lr,readOnlySelector:Mr,useRecoilValue:ta,useRecoilValueLoadable:na,useRecoilState:Qr,useRecoilStateLoadable:Yr,useSetRecoilState:aa,useResetRecoilState:oa,useGetRecoilValueInfo_UNSTABLE:io,useRetain:ra,useRecoilCallback:Jr,useGotoRecoilSnapshot:Zr,useRecoilSnapshot:Xr,useRecoilTransactionObserver_UNSTABLE:ea,useTransactionObservation_UNSTABLE:sa,useSetUnvalidatedAtomValues_UNSTABLE:ia,noWait:ua,waitForNone:fa,waitForAny:da,waitForAll:ca,waitForAllSettled:la,isRecoilValue:Hr,batchUpdates:Gr,setBatcher:Wr,snapshot_UNSTABLE:Kr},pa=ha.DefaultValue,va=ha.RecoilRoot,ya=ha.useRecoilBridgeAcrossReactRoots_UNSTABLE,ma=ha.atom,_a=ha.selector,ga=ha.retentionZone,Sa=ha.atomFamily,wa=ha.selectorFamily,ba=ha.constSelector,Ra=ha.errorSelector,Ta=ha.readOnlySelector,Aa=ha.useRecoilValue,Ea=ha.useRecoilValueLoadable,Na=ha.useRecoilState,ka=ha.useRecoilStateLoadable,Va=ha.useSetRecoilState,La=ha.useResetRecoilState,Ma=ha.useGetRecoilValueInfo_UNSTABLE,Ca=ha.useRetain,Ba=ha.useRecoilCallback,Ua=ha.useGotoRecoilSnapshot,Da=ha.useRecoilSnapshot,Ia=ha.useRecoilTransactionObserver_UNSTABLE,xa=ha.useTransactionObservation_UNSTABLE,Fa=ha.useSetUnvalidatedAtomValues_UNSTABLE,Oa=ha.noWait,za=ha.waitForNone,Pa=ha.waitForAny,Ga=ha.waitForAll,Wa=ha.waitForAllSettled,qa=ha.isRecoilValue,ja=ha.batchUpdates,Ha=ha.setBatcher,$a=ha.snapshot_UNSTABLE;t.default=ha}}]);
//# sourceMappingURL=0a301732.bd30e294401c6f80c0dd.js.map